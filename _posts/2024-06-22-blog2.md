---
layout: post
title: 도커 컨테이너 및 CLI
subtitle: Docker Study Note2
author: 코딩하는 랄로
categories: docker
tags: [docker, container]
---


저번 글을 통해서 도커는 컨테이너화 플랫폼이고 컨테이너는 무엇인지에 대해서 간략하게 다루었습니다. 이번 글에서는 도커 CLI 를 통해서 도커 컨테이너를 동작시키는 방법을 간단하게 알아보면서 컨테이너에 대해서 더 깊게 알아보고 도커 CLI 가 동작하는 방법에 대해서도 알아보겠습니다.


## 도커 컨테이너 명령어

본격적으로 도커 CLI 에 대해서 다루기 전에, 다시 한번 도커 컨테이너가 무엇인지에 대해서 간략하게 되짚어보고 넘어가겠습니다. 

도커 컨테이너는 애플리케이션을 실행시키기 위한 독립적인 가상의 리소스(격리된 환경)를 제공하기 때문에 어떠한 환경에서든지 일관되게 동작(이식성)할 수 있도록 해줍니다. 또한 VM 에 비해 가볍기 때문에 하나의 서버에서 여러개의 컨테이너를 띄우고 관리할 수 있습니다. 이러한 컨테이너를 실행하고 관리하는 주체는 바로 도커 엔진이고 사용자는 도커 CLI(명령행 인터페이스)를 통해서 도커 엔진에게 명령을 내릴 수 있게 됩니다. ( 더 구체적인 내요은 아래에서 다루겠습니다. )

그럼 컨테이너를 다루기 위한 기초적인 도커 CLI 는 무엇이 있는지 알아보겠습니다. 이 글에서 다루는 명렁어 말고도 더 많은 명령어를 알고 싶으신 분들은 아래의 명렁어를 통해서 확인할 수 있습니다.
  
```sh
docker container --help
```
  
<br>
# 컨테이너 실행 명렁어 : run

```sh
docker container run [IMAGE_NAME]
```

먼저 컨테이너를 실행하는 명렁어입니다. 컨테이너를 실행하기 위해서는 어떤 애플리케이션을 컨테이너에서 실행할 것인지를 명시해주어야 합니다. 도커에서는 컨테이너에 실행시키기 위한 애플리케이션을 이미지라고 부르는 형태로 패키징하게 되고 이를 컨테이너에 실행시키게 되는 것입니다. ( 다음 글에서 다루겠습니다. )

단순히 위의 명렁어를 통해서 컨테이너를 실행시킬 수 도 있지만, 여러 flag 를 통해 같은 이미지여도 다른 설정을 통해서 실행시킬 수 있습니다. ( flag 도 docker container run --help 를 통해 어떤 flag 들이 있는지 확인 가능합니다. )

그 중에서 몇가지 flag 들을 알아보겠습니다.
- d, detach : 컨테이너를 백그라운드에서 실행시키겠다는 설정입니다. 
- p, publish [HOST_PORT]:[IMAGE_PORT]: 컨테이너의 내부 포트를 호스트 컴퓨터의 포트로 바인딩하는 옵션입니다. 즉, 외부로 공개하기 위한 옵션입니다. 애플리케이션은 Port 번호를 가지게 되고 이를 컨테이너에 실행하게 되면 도커가 해당 포트를 가상의 리소스로서 제공해줍니다. 그렇기 때문에 외부의 사용자가 해당 컨테이너의 포트로 접근할 수 있는 방법이 없습니다. 때문에 컨테이너 내부의 가상 포트를 실제 호스트 컴퓨터의 포트로 공개하게 되면 도커 엔진이 호스트 컴퓨터로 들어오는 요청을 주시하고 있다가 지정해준 포트에 대한 요청을 해당 컨테이너의 가상 포트를 전달해주는 것입니다.
- e, env [key]=[value]: 컨테이너의 환경 변수를 설정해줍니다. 특정 애플리케이션은 환경 변수 값을 가져와서 사용하는 경우도 있고 이를 이미지 빌드할 때 미리 정의해줄수도 있지만 환경에 따라 다르게 설정해주고 싶을 때는 해당 flag 를 통해서 변경할 수 있습니다.
- name : 실행시킬 컨테이너의 이름을 지정해줍니다. 해당 flag 가 없으면 도커가 임의로 유니크한 값을 지정해줍니다.
- mount : 호스트의 파일 시스템을 도커의 파일 시스템에 연결하기 위한 설정입니다.
- v, volume : 도커 볼륨을 도커의 파일 시스템에 연결하기 위한 설정입니다.
- i, interactive : detach flag 설정이 되어 있는 상황에서 stdin (표준입력스트림) 을 열어두기 위한 설정입니다.
- t, tty : 터미널 세션을 컨테이너에게 할당해주기 위한 설정입니다. 보통 i 와 t flag 를 같이 쓰며( -it ) 이럴 경우, 터미널을 통해서 stdin 이 연결되고 이를 통해 컨테이너를 조작할 수 있게 됩니다.
- network : 도커 네트워크를 지정해주기 위한 설정입니다.
  
이 외에도 여러 옵션들이 있기 때문에 상황에 따라 적절한 옵션을 지정해주면 됩니다. 
  
<br>
# 그 외

docker container run 이 외에도 몇 가지 기초적인 명렁어들을 알아보겠습니다.
- ls : 현재 실행중인 컨테이너의 목록을 보여줍니다. 실행중이지 않은 목록도 보고 싶으면 -a, --all flag 를 사용하면 됩니다.
- start : 중지된 컨테이너를 실행시키기 위한 명렁어입니다.
- stop : 실행중인 컨테이너를 중지시킵니다.
- rm : 컨테이너를 삭제합니다. 실행중인 컨테이너를 삭제하기 위해서는 -f flag 를 사용해야 합니다.
- stats : 실행중인 특정 도커 컨테이너의 상태를 실시간으로 확인하는 명령어입니다. ( CPU, 메모리, 네트워크, 디스크 사용량 등 )
- inspect : 지정한 컨테이너의 상세 정보를 열람하기 위한 명렁어입니다. ID, 생성일시, 가상 파일 시스템상의 경로, 컨테이너에서 실행중인 명령어, 해당 컨테이너가 접속된 가상 도커 네트워크 정보 등 여러 정보가 JSON 포맷으로 제공됩니다.
- exec : 실행중인 컨테이너 내부의 command 를 실행시킵니다.
- logs : 컨테이너의 로그를 볼 있습니다.
  
여기서 잠깐 짚고 넘어갈 부분은 도커는 컨테이너가 중지(실행종료)되었다고 해당 컨테이너를 바로 삭제하지 않는다는 것입니다. rm 명렁어를 통해서 명시적으로 삭제해주지 않는 한 계속해서 남아있게 됩니다. 그렇기 때문에 언제든지 해당 컨테이너의 파일시스템에 접근할 수 있고 로그를 확인하는 것 또한 가능합니다.

> **kill vs stop**<br>
> 도커 컨테이너를 종료시키기 위한 명렁어로는 kill 과 stop 두가지 명렁어가 있습니다. 두개의 명렁어의 차이는 무엇일까요?
>
> > **stop**
> > stop 을 사용하면 도커가 SIGTERM 시그널을 컨테이너에게 보내 정상적인 종료 절차를 시작하도록 합니다. 그 후 종료될때까지 기다려 주고 일정시간이 지난 후에도 종료되지 않으면 SIGKILL을 보내어 강제 종료됩니다. 즉 , stop은 컨테이너가 자체적으로 정리 작업을 수행할 수 있는 시간을 제공하는 것입니다.
>
> > **kill**
> > kill 명렁어를 사용하면 바로 SIGKILL 을 보내어 강제 종료해버립니다. 그렇기 때문에 컨테이너의 정리 작업 또는 상태 저장 작업 등이 이루어지지 않게 됩니다.
>
> 대부분의 상황에서 시스템의 안정성을 고려해서 stop 명렁어를 사용하는 것을 권장하지만 긴급한 상황에서 컨테이너가 반응하지 않고 종료되어야 할 때는 kill 을 사용합니다.
  
  

## 도커 컨테이너는 어떻게 실행되나

도커 컨테이너는 도커 엔진에 의해서 관리됩니다. 도커 엔진은 도커의 관리 기능을 맡은 컴포넌트로 컨테이너의 관리 뿐만 아니라 로컬 이미지 캐시, 운영체제와 함께 가상 네트워크 등 도커 리소스를 만들고 관리하는 일도 모두 담당합니다. 이러한 도커 엔진은 도커 API 를 통해서 동작하면 이 API 는 HTTP 기반에 REST API 입니다. 그렇기 때문에 도커가 설치만 되어 있다면 어떤 환경인지와 관련없이 (API 는 동일하기 때문에) 도커를 관리할 수 있습니다.
  
또한 도커 엔진과 상호작용할 수 있는 방법은 이 API 로만 가능하고 도커 CLI 는 API 에 요청을 전달하는 역할로 오직 도커 CLI 만이 해당 API 의 클라이언트이기 때문에 원격에서 접근해서 도커를 관리하기 위해서 도커 API 를 이용하는게 아니라 도커 CLI 를 통해서 관리하게 됩니다.

> **OCI**<br>
> 도커 엔진은 containered라는 컴포넌트를 통해 컨테이너를 실제로 관리를 합니다. 이 containered는 호스트 운영체제가 제공하는 기능을 이용해서 가상의 리소스를 만들어서 컨테이너에게 제공하는 역할을 합니다. 이러한 containered 는 CNCF(Cloud Native Computing Foundation) 에서 관리하는 오픈 소스 프로젝트이며, 컨테이너는 개방형 컨테이너 이니셔티브(Open Container Initiative, OCI)로 공개된 개방형 표준입니다.



